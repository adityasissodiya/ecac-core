Got it. Here’s a tight, no-nonsense **Milestone 1 (M1)** that’s big enough to be meaningful and small enough to not drown you.

# M1 — Signed, Hash-Linked Ops + Causal DAG (no policy, no networking)

## Goal (what M1 proves)

You can create, serialize, sign, verify, and hash-link operations; store them in a causal DAG; and derive a **deterministic total order** (topo + tie-break). That’s it. No replay, no deny-wins, no networking, no storage beyond in-memory. This gives you a rock-solid base for M2.

---

## Scope (what’s in vs. out)

**In**

* `Op` schema (metadata + minimal typed payloads)
* Deterministic serialization (canonical CBOR)
* Content hashing (BLAKE3) for `op_id`
* Per-op signing/verification (ed25519)
* Causal parents (`parents: Vec<OpId>`) + DAG build
* Deterministic topological sort with a defined tie-break: `(hlc, op_id)`
* CLI toy to generate keys / create ops / print DAG / verify ops
* Unit + property tests for integrity, determinism, and DAG correctness
* Protocol doc (one pager) pinning formats and rules

**Out (explicitly)**

* Policy/credentials/deny-wins
* Replay/materialized state
* Persistent store (RocksDB), networking, encryption
* DSM anything

---

## Deliverables

### Code (under your current repo layout)

* `crates/core/src/op.rs`

  * `Op` struct:

    ```rust
    struct Op {
      op_id: OpId,               // computed (BLAKE3 over canonical bytes)
      parents: SmallVec<[OpId; 2]>,
      hlc: Hlc,                  // hybrid logical clock
      author: PublicKey,         // ed25519
      payload: Payload,          // enum below
      sig: Signature,            // ed25519 over hash
    }
    enum Payload {
      Data(SetField { obj: Uuid, field: String, value: Bytes }),
      Policy(Grant { user: PubKeyBytes, role: String, scope: StepTag }),
      Policy(Revoke { user: PubKeyBytes, role: String, scope: StepTag }),
      // You won’t *use* Policy in M1—kept for forward compat.
    }
    ```
* `crates/core/src/crypto.rs`

  * Ed25519 keygen, sign, verify (ed25519-dalek)
  * BLAKE3 hashing
* `crates/core/src/dag.rs`

  * In-memory DAG (index by `op_id`, parent/child edges)
  * Kahn topo sort; tie-break on `(hlc, op_id)`
  * Dedup and unknown-parent handling (ops accepted “pending parents”)
* `crates/core/src/serialize.rs`

  * Canonical CBOR encode/decode (serde_cbor with `canonical=true`)
  * Clear statement of exactly which fields are hashed and in what order
* `crates/cli/`

  * `gen-key`, `new-op`, `verify-op`, `print-dag`, `topo-order`

### Docs

* `docs/protocol.md` (<= 3 pages)

  * Field definitions
  * Canonical serialization rule (CBOR canonical; bytes that get hashed)
  * `op_id = BLAKE3(canonical(OpHeader+Payload))`
  * Signature input = `op_id` (not raw CBOR)
  * HLC update rule (on local create vs on receive)
  * Topo + tie-break rule (stable, total)

---

## Acceptance criteria (binary, testable)

1. **Deterministic ID**

   * Same logical op → same `op_id` across machines/runs.
   * Any bit flip in payload/metadata → different `op_id`.

2. **Signature correctness**

   * Valid op verifies; any change to any hashed field fails verification.

3. **Causal DAG**

   * DAG accepts ops in any arrival order; topo order is identical across runs.

4. **Total order determinism**

   * Given the same set of ops, all nodes produce **the same** linear order (topo + `(hlc,op_id)` tie-break).

5. **Dedup & unknown parents**

   * Re-inserting an op is a no-op.
   * Op with unknown parents is staged; becomes active when parents arrive.

6. **HLC sanity**

   * Monotonic per node; on receive: `hlc = max(local, remote)+epsilon` (document exact rule).

7. **CLI smoke**

   * Can generate keys, create a 3-op branchy graph, print order, and verify all signatures.

---

## Test plan (minimal but covers correctness)

**Unit tests (core)**

* `serialize_roundtrip`: CBOR round-trip yields identical `op_id`.
* `signature_tamper`: flip one byte → signature verify fails.
* `dag_topo_order`: multiple insertion orders → same topo result.
* `tie_break_stability`: construct same-hlc concurrent ops → order by `op_id` stable.
* `pending_parents`: insert child first, then parents → topo includes both, correct order.
* `hlc_rules`: local create increments; receive bumps correctly.

**Property tests (proptest)**

* Generate random DAGs with up to N=200 ops; insert in random permutations; assert:

  * Same topo on repeated runs
  * All edges point parent before child in order
  * All signatures verify

**CLI e2e**

* Script: create keys A/B; make 5 ops with mixed parents; dump topo; verify; repeat → identical output.

---

## Implementation notes (to avoid foot-guns)

* **Canonical encoding:** use `serde_cbor::ser::Serializer::new(...).canonical(true)`. Commit to CBOR map key ordering and integer width rules. Don’t roll your own.
* **Hash domain separation:** prefix a constant, e.g., `BLAKE3("ECAC_OP_V1" || canonical_bytes)`.
* **Sign the hash, not the bytes.** Smaller, sidesteps encoding quirks.
* **HLC**: store as `(physical_ms, logical_counter, node_id)`; compare lexicographically.
* **Tie-break**: `(hlc, op_id)` where `op_id` is 32-byte BLAKE3 digest (lexicographic).
* **Parents cap:** smallvec with 2 typical parents; still handle N>2 for merges.
* **No unsafe.** Keep crypto isolated; zeroize secrets if you touch them (M1 can skip zeroize if it complicates).

---

## Non-goals (call them out so nobody wastes time)

* No policy checks, no “authorized epochs,” no replay/deny-wins.
* No RocksDB, no libp2p, no gRPC.
* No encryption or credential verification (just signatures).

---

## Task breakdown (checklist you can knock out)

* [ ] `op.rs`: define types; implement `Op::new(...)` (computes `op_id`, signs)
* [ ] `serialize.rs`: canonical encode/decode; tests for stability
* [ ] `crypto.rs`: keygen, sign, verify; tests
* [ ] `dag.rs`: add/get, topo sort, pending queue; tests
* [ ] `hlc.rs`: small module for HLC ops; tests
* [ ] `cli`: basic commands
* [ ] `docs/protocol.md`: frozen by end of M1
* [ ] Property tests for determinism

---

## Risks to watch (so you don’t chase ghosts)

* **Non-canonical serialization** → different `op_id`s on different machines. Stick to canonical CBOR and test it hard.
* **Time dependence** → HLC mistakes can cause nondeterministic order; document rules and test with mocked clocks.
* **Hidden fields in hash** → be explicit which fields are hashed/signed; don’t include `sig` or `op_id` themselves.

That’s M1. Tight, verifiable, and it sets you up for M2 (deny-wins replay) without rework.
