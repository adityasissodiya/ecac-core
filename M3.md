Perfect—M3 is where we add **authorization** and **deny-wins** into the replay. Keep it tight.

# M3 — Authorization Epochs + Deny-Wins Replay (no networking, no persistence)

## Goal (what M3 proves)

Given the op DAG and data replay from M1/M2, you can **filter out unauthorized ops deterministically**. Policy is expressed as log events (grant/revoke/expire + static rules). The replay builds **auth epochs** per identity, applies **deny-wins**, and yields a **policy-correct** materialized state.

---

## Scope (what’s in vs out)

**In**

* Policy event types in the same log:

  * `Grant { subject_pk, role, scope_tags, not_before, not_after }`
  * `Revoke { subject_pk, role, scope_tags }`
  * (optional) `CredentialRef { subject_pk, cred_hash }` (stored, not validated yet)
* A minimal **policy model**:

  * RBAC-ish: *(subject, action, resource_tags)* allowed iff subject has a **currently valid** grant for *(role → permissions)* that covers the action + resource tags.
  * Static role→permission mapping baked in code (table).
* **Auth epochs**: for each `(subject, role, scope)` build time intervals from grants minus revocations.
* **Deny-wins replay**: while replaying data ops from M2, **skip** any op whose `(author, action, resource_tags, op_hlc)` is **not inside a valid epoch**.
* **Deterministic behavior**: same events → same filtered state on all nodes.
* Unit + property tests for policy safety and convergence with policy.

**Out**

* Verifiable Credential cryptography (full VC validation) — **defer to M4**.
* Fancy ABAC attributes (location/time/shift) — stick to tags + time window.
* Persistence, networking, encryption — still out.

---

## Deliverables

### Code

* `crates/core/src/policy.rs`

  * Types:

    ```rust
    struct Grant { subject: PubKey, role: Role, scope: TagSet, nbf: Hlc, naf: Option<Hlc> }
    struct Revoke { subject: PubKey, role: Role, scope: TagSet, at: Hlc }
    enum Action { SetField, SetAdd, SetRem }  // matches data ops
    struct Permission { action: Action, required_tags: TagSet }
    static ROLE_PERMS: &'static [ (Role, Vec<Permission>) ];
    ```
  * `build_auth_epochs(events) -> EpochIndex`

    * For each `(subject, role, scope)` produce ordered, non-overlapping intervals `[start, end)`.
    * Revocation splits/caps intervals.
  * `is_permitted(epoch_index, author, action, resource_tags, at_hlc) -> bool`

    * Checks time ∈ epoch, and `resource_tags ⊇ required_tags` for some matching `(role, permission)` with overlapping scope.
* `crates/core/src/replay.rs`

  * Integrate **policy filter** before applying data op:

    ```rust
    if is_permitted(...) { apply_data_op(...) } else { /* skip */ }
    ```
  * Ensure **full** and **incremental** replay paths both call the same check.
* `crates/core/src/op.rs`

  * Finalize `Payload::Grant`, `Payload::Revoke` variants with fields above.
  * Add `resource_tags: TagSet` and `action: Action` derivation for each data op (e.g., from `(obj, field)` → tags via a static map).
* `crates/core/src/state.rs`

  * Optional: annotate state with tombstones for skipped ops in debug mode (for CLI display).
* `crates/cli/src/simulate.rs`

  * Scenario driver for **offline edit + concurrent revoke** and **grant-regrant** cases.
  * Pretty print: applied vs skipped ops and final state.

### Docs

* `docs/policy-model.md`

  * 2–3 pages: roles→permissions table, tag model, epoch construction, deny-wins rule.
* `docs/architecture.md`

  * Add “Replay with Policy Filter” section + sequence diagram (events → epochs → filtered apply).

---

## Acceptance criteria (binary)

1. **Policy safety**
   For any log where a `Revoke` happens before a user’s data op (by DAG HB or by HLC in the total order), that op **does not** affect final state.

2. **Convergence with policy**
   Any permutation of delivery for the same event set produces **identical** filtered state.

3. **Epoch correctness**

   * Grant then Revoke → ops in [grant, revoke) allowed; ≥ revoke **denied**.
   * Re-grant after revoke → ops in the second interval allowed again.

4. **Scope & tags**

   * A grant limited to `{"hv-test"}` permits only data ops whose `resource_tags` include `hv-test`.
   * Same user editing `{"mechanical"}` without that tag → **skipped**.

5. **Incremental parity**

   * `replay_full(all)` equals `replay_full(part1); apply_incremental(part2)` with policy applied in both.

6. **Determinism under concurrency**

   * Concurrent `Grant` and data op: if total order puts `Grant` first → allowed; otherwise **skipped**. All replicas agree.

---

## Test plan

**Unit tests**

* `grant_allows`: grant(HV) then op(HV) → applied.
* `revoke_denies`: revoke(HV) before op(HV) → skipped.
* `regrant_restores`: grant(HV), revoke(HV), grant(HV2), op in second window → applied.
* `scope_mismatch`: grant(mech) and op(hv) → skipped.
* `overlapping_scopes`: grant({hv, mech}), op(mech) → applied; op(hv) → applied.

**Policy/DAG interaction tests**

* `concurrent_grant_op_caseA`: total order: grant < op → applied.
* `concurrent_grant_op_caseB`: op < grant → skipped.
* `revoke_vs_op_concurrent`: both present, resolve by total order; assert deny-wins if revoke < op.

**Property tests (proptest)**

* Generate random sequences of `Grant/Revoke` + data ops over small tag universe and 2–3 subjects.
* Assert:

  * No op outside any valid epoch changes state.
  * Convergence across permutations.

**E2E (CLI scenarios)**

* `offline_edit.rs`: user edits while offline, admin revokes in parallel → on reconcile, edit disappears.
* `grant_after_edit.rs`: edit happens, then grant (out of order arrival) → still **skipped** (not retroactive).

---

## Implementation notes

* **Epoch construction**

  * Process policy events in the **same total order** used for data replay.
  * Maintain map `(subject, role, scope) → Vec<Interval>`.
  * `Grant` opens an interval at `max(nbf, current_clock)`; `not_after` caps it.
  * `Revoke` closes any **open** intervals that overlap its scope at `at`.
  * Normalize (merge adjacent intervals with same bounds) for efficient queries.

* **Scope overlap**

  * Treat `scope` and `resource_tags` as sets; permission applies if `resource_tags ∩ scope ≠ ∅` (pick one rule and **freeze it**; simplest is “intersects”).
  * Keep this rule **simple** in M3; richer ABAC can come later.

* **Action mapping**

  * `SetField` → `Action::SetField` (`required_tags` from `(obj,field)` → tags table).
  * `SetAdd/SetRem` → `Action::{SetAdd,SetRem}` likewise.

* **Order source of truth**

  * Policy events live in the same DAG and use the **same** topo + tie-break. No side channels.

* **No time-of-day** deps

  * Use **HLC** only from event metadata; do not consult system clock at replay.

---

## Non-goals

* No external credential validation (treat grants as ground truth in the log).
* No partial revocation semantics (e.g., revoking only future keys)—keep it simple.
* No read-access controls; this is **write enforcement** only.

---

## Task checklist

* [ ] Define `Grant/Revoke` payloads; extend `Action`/`TagSet`
* [ ] Implement `build_auth_epochs` + tests
* [ ] Wire policy filter into `replay` paths
* [ ] Add static `ROLE_PERMS` and `(obj,field) → TagSet` resolver
* [ ] CLI simulations for revoke/rollback and re-grant
* [ ] Property tests for safety + convergence
* [ ] Update docs (`policy-model.md`, architecture diagram)

---

## Risks / foot-guns

* **Ambiguous scope semantics** → pick “intersects” or “superset” and stick to it; tests must encode it.
* **Order inconsistency** → policy epochs **must** be built from the **same** total order as data ops.
* **Hidden retroactivity** → do **not** allow a later `Grant` to validate a past op. Deny-wins means “no retroactive authorization.”

M4 can then add **credential verification (W3C VC / status lists)** and **revocation-by-credential** without touching M3’s core deny-wins logic.
