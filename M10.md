Locked. M10 = **trust + revocation distributed in-band**. No more side files; issuer keys and status lists ride the same signed log, so the system is self-contained and deterministic.

# M10 — In-Band Trust & Revocation (Issuer Keys, Status Lists, Key Rotation)

## Goal

Distribute and version **issuer public keys** and **credential status lists** as first-class signed ops in the log. VC verification (from M4) now uses only on-log artifacts. All replicas that see the same events reach the same trust view and make the same allow/deny decisions.

---

## Scope

**In**

* New op types:

  * `IssuerKey { issuer_id, key_id, algo, pubkey, valid_from, valid_until, prev_key_id? }`
  * `IssuerKeyRevoke { issuer_id, key_id, reason }`
  * `StatusListChunk { list_id, issuer_id, version, chunk_index, bitset_sha256, chunk_bytes }`
  * `StatusPointer { cred_id, list_id, index }`  *(optional if already in VC)*
* **TrustView** builder that derives the **active key set** per issuer and the **latest status list** per `list_id` from the same total order used for replay.
* VC verification reads issuer keys and status from **TrustView**, not the filesystem.
* Deterministic conflict rules for key rollovers and status list updates.
* Back-compat: still accept filesystem trust/status behind a `--bootstrap` flag to seed the first keys if needed.

**Out**

* Online DID resolution, HTTP fetching, OCSP.
* Multi-issuer quorum policies—single-issuer trust only in M10.

---

## Deliverables

### Code

* `crates/core/src/trustview.rs`

  * `struct TrustView { issuers: HashMap<IssuerId, ActiveKey>, status: HashMap<ListId, StatusList> }`
  * `fn build(events: impl Iterator<Op>) -> TrustView`
    Processes `IssuerKey*` and `StatusListChunk` in **total order**; yields active keys and assembled status lists.
  * `fn verify_vc(&self, vc: &JwtVc) -> Result<VerifiedVc>`
    Uses issuer’s **active** key (by `iss` + `kid`) and `status` to check revocation.

* `crates/core/src/op.rs`

  * Add payload variants for `IssuerKey`, `IssuerKeyRevoke`, `StatusListChunk`, `StatusPointer`.

* `crates/core/src/vc.rs`

  * Modify verifier to take `&TrustView` instead of filesystem `TrustStore`/`StatusCache`.
  * Enforce `nbf/exp` using op HLC physical like in M4.

* `crates/core/src/replay.rs`

  * Build **TrustView** once per replay (full) and incrementally update on new ops.
  * VC-backed grant epochs use the TrustView.

* `crates/cli/`

  * `issuer-publish-key --issuer <id> --key <pub.pem> --kid <id> --valid-from <hlc> --valid-until <hlc>` → emits `IssuerKey`.
  * `issuer-revoke-key --issuer <id> --kid <id> --reason <txt>` → emits `IssuerKeyRevoke`.
  * `status-publish --list <id> --version <v> --chunk <i> --file <chunk.bin>` → emits `StatusListChunk`.
  * `trust-dump` → prints the derived TrustView (active keys, status list digests).

### Docs

* `docs/policy-model.md` → “In-band trust” section: issuer key lifecycle, status list assembly, precedence rules.
* `docs/protocol.md` → schemas for `IssuerKey*`, `StatusListChunk`, encoding (canonical CBOR), and size limits.
* `docs/architecture.md` → updated pipeline diagram: Ops → TrustView → VC Verify → Epochs → Deny-wins → State.

---

## Deterministic rules (freeze these)

**Issuer keys**

* Identify key by `(issuer_id, key_id)`.
* **Activation:** An `IssuerKey` becomes active at `max(valid_from, op.hlc)` in the total order.
* **Expiry:** Not valid after `valid_until`.
* **Revoke op** immediately deactivates the key from its position in the total order onward.
* **Multiple active keys:** Allowed; VC `kid` selects the key; if missing `kid`, pick the lexicographically highest `(valid_from, key_id)` ≤ VC `nbf`.

**Status lists**

* Identified by `(issuer_id, list_id, version)`.
* A list is a set of fixed-size **chunks** (bitset blocks).
* Latest **complete** version (all chunks observed) supersedes earlier ones.
* If multiple versions are incomplete, use the **highest version** where all seen chunks match the advertised `bitset_sha256`.
* VC revocation check uses the **highest complete version** ≤ op HLC physical time; if none complete, treat as **not revoked** (fail-safe toward availability; document).

---

## Acceptance criteria (binary)

1. **Self-contained verification**

   * With the filesystem trust disabled, VC verification succeeds/fails purely from in-band `IssuerKey*` and `StatusListChunk` ops.

2. **Deterministic trust view**

   * Given the same event set, all nodes derive **identical** active key sets and status lists.

3. **Key rollover**

   * Publish `IssuerKey(k1)` then `IssuerKey(k2)`; VCs with `kid=k1` validate before rollover; after rollover time for VCs with `kid=k2` validate; revoking `k1` invalidates subsequent VCs signed with `k1`.

4. **Status update effects**

   * Publishing a status list that marks `cred_id` revoked causes subsequent ops tied to that VC to be **skipped** (deny-wins) from that point forward.

5. **Cross-checks**

   * `trust-dump` outputs digest of active issuers and status lists; digests match across nodes.

---

## Test plan

**Unit**

* `issuer_activate_expire`: valid_from/valid_until windows enforced.
* `issuer_revoke`: revoke deactivates immediately; VC fails thereafter.
* `status_assemble`: assemble list from chunks; wrong `bitset_sha256` rejected.

**Integration**

* Scenario A (rollover):

  * Publish `k1`; accept VC1 (kid=k1).
  * Publish `k2`; accept VC2 (kid=k2) after rollout point.
  * Revoke `k1`; future VC1 fail, VC2 still pass.

* Scenario B (revocation):

  * Publish status v1 with bit unset; ops allowed.
  * Publish status v2 with that bit set; later ops from that VC skipped.

* Scenario C (incomplete status):

  * Publish partial chunks; ensure verifier uses last complete version or treats as not revoked per rule.

**Property**

* Random sequences of IssuerKey/Revokes/StatusChunks interleaved with Grants and data ops; assert:

  * Deterministic TrustView digests across permutations.
  * No op is applied when VC is invalid under the TrustView.

**CLI**

* Run `issuer-publish-key` / `status-publish` to seed trust; feed sample VCs; `trust-dump` should show expected keys and list digests; replay shows allow/deny as expected.

---

## Implementation notes

* **Auth for trust ops**
  Who’s allowed to publish `IssuerKey*` and `StatusListChunk`? For prototype: require they be **signed by a special “issuer admin” user key** whose VC says `role=issuer_admin`. Your deny-wins policy should treat trust ops as write actions gated by that role.

* **Bounded sizes**
  Enforce max sizes: pubkey ≤ 1KB, chunk ≤ 64KB, total list ≤ a few MB. Reject oversize with `SkippedOp{reason="invalid_trust_payload"}`.

* **Hashing**
  Store a digest per assembled status list: `digest = sha256(concat(chunks))` for quick equality checks; keep advertised `bitset_sha256` inside each chunk op and verify.

* **Time**
  Use **op HLC physical** for evaluating `valid_from/until` and picking the latest status version; do not read wall clock.

* **Bootstrap**
  Optional: allow `--bootstrap issuers.toml` on the very first run to emit corresponding `IssuerKey` ops into the log. After that, disable filesystem trust.

---

## Non-goals

* Multi-issuer chain of trust, DID resolution.
* M-of-N signer policies.
* Status deltas/compact proofs; we ship full chunks for simplicity.

---

## Task checklist

* [ ] Add op variants + encoding
* [ ] Implement `TrustView::build` + incremental update
* [ ] Wire VC verification to TrustView
* [ ] Enforce authorization for trust ops (issuer_admin)
* [ ] CLI: publish/revoke keys, publish status chunks, dump trust
* [ ] Tests: unit, integration, property
* [ ] Docs: protocol/policy/architecture updates

---

## Risks / foot-guns

* **Order sensitivity**: TrustView must be built from the **same** total order as replay; never from arrival order.
* **Partial status versions**: define and test the “latest complete” rule to avoid nondeterminism.
* **Key conflicts**: two `IssuerKey` ops with same `(issuer_id, key_id)` but different pubkeys—define behavior: **first one wins**, later conflicting op is `SkippedOp{reason="key_conflict"}`.
* **Privilege escalation**: ensure only `issuer_admin` can publish trust ops; test deny path.

Ship M10 and your prototype becomes **fully self-contained**: any reviewer can clone the repo, run the scenarios, and see trust and revocation flow entirely through the same signed, hash-linked log—no hidden side channels.
