Locked. M11 is **reproducibility & packaging** so a reviewer can clone, run one script, and get the exact same artifacts you cite in the paper—byte for byte.

# M11 — Reproducible Builds, One-Click Runs, and Paper Artifacts

## Goal

Make the prototype **deterministic to build and run**, with a **single command** that:

1. boots a clean workspace,
2. runs M7 benchmarks and key scenarios,
3. emits **identical JSON/CSV artifacts** (and optional PNGs),
4. verifies integrity (ops, audit, trust), and
5. bundles everything into a **submission tarball**.

No new features—just discipline.

---

## Scope (in vs out)

**In**

* Pinned toolchain and dependencies
* Hermetic build environment (container/Nix)
* “Reproduce everything” script
* Golden artifact hashing + verification
* CI that runs the same pipeline
* Supply-chain checks (audit, SBOM, signatures)

**Out**

* Fancy installers, OS service packaging
* Optimization for speed; correctness wins

---

## Deliverables

### 1) Toolchain pinning

* **Rust**: add `rust-toolchain.toml` (e.g., `channel = "1.80.0"`; exact) and commit `Cargo.lock`.
* Set `RUSTFLAGS="-C debuginfo=0 -C strip=symbols -C link-arg=-s"` for stable, smaller deterministic binaries.
* Vendor build scripts’ inputs if any (avoid network at build time).

### 2) Hermetic env

Pick one and freeze:

**Option A — Docker (simpler)**

* `Dockerfile.build`:

  * base: `debian:stable-slim`
  * install rustup pinned toolchain, `clang`, `pkg-config`, `protobuf-compiler`, `libssl-dev`
  * set `ENV CARGO_HOME=/usr/local/cargo`, `RUSTFLAGS` as above
* `Makefile` targets:

  * `make image` → builds container
  * `make repro` → runs container with a clean volume and calls `scripts/reproduce.sh`

**Option B — Nix (more rigorous)**

* `flake.nix` with pinned `rust-overlay`, `protobuf`, `openssl`, `rocksdb`; `nix develop` gives the exact env.

(You can ship both; Docker for most users, Nix for purists.)

### 3) Reproduce script

`scripts/reproduce.sh` (POSIX, no magic):

1. **Clean workspace** in a temp dir.
2. **Build** all crates with `--locked` and `--release`.
3. **Run** deterministic scenarios (M7):

   * `cli bench run --scenario hb-chain --seed 42 …`
   * `cli bench run --scenario concurrent --seed 42 …`
   * `cli bench run --scenario offline-revoke --seed 42 …`
   * `cli node` multi-peer scenario only if `--net` feature enabled (document).
4. **Export**:

   * `dump-state-json` for each run
   * `audit-export` + `audit-verify`
   * `trust-dump`
5. **Hash** outputs to `SHA256SUMS` (stable file order).
6. **Bundle** to `docs/eval/out/ecac-artifacts-<gitsha>.tar.gz`.
7. Print a short summary table to stdout.

All outputs under `docs/eval/out/` with fixed filenames:

```
docs/eval/out/
  hb-chain-42.csv
  hb-chain-42-timeline.jsonl
  hb-chain-42-state.json
  concurrent-42.csv
  ...
  audit.jsonl
  audit.verify.txt
  trustview.json
  SHA256SUMS
  ecac-artifacts-<gitsha>.tar.gz
```

### 4) Golden set + verifier

* `docs/eval/golden/` contains the **golden** outputs for the commit you cite in the paper.
* `scripts/verify_golden.sh`:

  * Re-run `reproduce.sh` in a temp tree.
  * Compare `SHA256SUMS` and per-file `sha256sum -c`.
  * Fail loudly on any mismatch; print first diff line for JSON if needed.

### 5) CI pipeline (GitHub Actions)

`.github/workflows/repro.yml`:

* Matrix for `{linux}` (and optionally `{mac, nix}` if you want).
* Steps:

  * checkout with LFS off
  * build Docker image or enter Nix shell
  * run `scripts/reproduce.sh`
  * run `scripts/verify_golden.sh`
  * run `cargo audit` and `cargo deny` (license/compliance)
  * upload `ecac-artifacts-<gitsha>.tar.gz` as workflow artifact
* Status badge in `README.md`.

### 6) Supply chain hygiene

* `cargo-audit` → fail on known vulns.
* `cargo-deny` → verify licenses (MIT/Apache set).
* Generate **SBOM** (CycloneDX): `cargo cyclonedx` → `sbom.json`.
* Sign the artifact with **Sigstore (cosign)** (optional):

  * `cosign sign-blob docs/eval/out/ecac-artifacts-<gitsha>.tar.gz > cosign.sig`
  * Document verify step.

### 7) Paper hooks

* `docs/eval/README.md`: exact commands to regenerate plots, cite artifact hash.
* If you include PNG plots, add `scripts/plot.py` to regenerate from CSV; also hash the PNGs.

---

## Acceptance criteria (binary)

1. **One-command reproduction**

   * `make repro` (Docker) or `nix develop && scripts/reproduce.sh` (Nix) completes with zero prompts and writes all expected files.

2. **Bit-for-bit repeatability**

   * Running the pipeline twice on the same commit yields **identical** `SHA256SUMS`.

3. **Golden match**

   * `scripts/verify_golden.sh` passes on CI for the tagged paper commit.

4. **Integrity checks pass**

   * `audit-verify` reports OK.
   * `trust-dump` matches expected digest printed in README (show SHA256 of TrustView JSON).
   * `cargo audit` reports no vulnerable deps (or explicitly allowed with justification).

5. **No network during build**

   * With `--locked` and container/Nix, build does not fetch from the internet after the image/shell is prepared.

---

## Test plan

**Local**

* Run `make image && make repro` → check artifacts and SHA256SUMS.
* Run `scripts/verify_golden.sh` → must pass.

**Adversarial**

* Flip one byte in `hb-chain-42.csv` → `verify_golden.sh` fails with clear message.
* Remove an output file → repro fails.

**CI**

* Ensure PRs cannot merge unless repro + golden match + audits pass.

---

## Implementation notes (avoid foot-guns)

* **File ordering**: Any time you write multiple outputs, **sort** filenames before hashing or bundling. Tar with `--sort=name --mtime='UTC 1970-01-01' --owner=0 --group=0 --numeric-owner` to get deterministic tarballs.
* **Env control**: In scripts, set `LC_ALL=C`, `TZ=UTC`, and export `SOURCE_DATE_EPOCH=1` to help reproducible artefacts.
* **Randomness**: Every benchmark takes a **seed**; never generate seeds implicitly. Record `seed` and `git sha` in the CSV header (you already planned that in M7).
* **Time**: No wall-clock in outputs; if you must print a time, use the **op/log HLC** or a constant “build timestamp” derived from `SOURCE_DATE_EPOCH`.
* **Binary stripping**: Use the `strip` flags already listed so debug paths don’t leak into hashes.
* **Proto/CBOR schemas**: freeze versions in `docs/protocol.md`; include the schema hash in the CSV header to catch drift.

---

## Repo changes (concrete)

* `rust-toolchain.toml` (pinned)
* `Makefile` (`image`, `repro`, `audit`, `sbom`)
* `Dockerfile.build` (or `flake.nix`)
* `scripts/reproduce.sh`, `scripts/verify_golden.sh`, (optional) `scripts/plot.py`
* `.github/workflows/repro.yml`
* `docs/eval/golden/` (committed for the paper tag)
* Update `README.md` with a **Reproduce** section and CI badge

---

## Task checklist

* [ ] Pin toolchain; commit lockfile
* [ ] Add Dockerfile.build (and/or Nix flake)
* [ ] Implement `scripts/reproduce.sh`
* [ ] Create golden artifacts; add `verify_golden.sh`
* [ ] Wire CI (`repro.yml`) + badges
* [ ] Add cargo audit/deny + SBOM
* [ ] Update docs with exact commands and artifact hashes

---

## Risks & mitigations

* **OS drift**: build inside the pinned container/shell only.
* **Hidden nondeterminism** (file mtimes, tar order): use deterministic tar flags and sorted file lists.
* **Plot nondeterminism**: if you render PNGs, fix the matplotlib backend, font, DPI, and seed; or ship only CSVs.
* **Dependency changes**: `--locked` builds + CI will catch accidental updates.

Ship M11 and you’ve removed the classic “works on my machine” excuse. Reviewers get a tarball and a command; it reproduces exactly what you claimed.
