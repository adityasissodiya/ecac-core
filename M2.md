Great, we’ll keep it tiny and surgical.

# M2 — Deterministic Replay → Materialized State (no policy)

## Goal (what M2 proves)

Given the signed, hash-linked op DAG from M1, you can **replay** it deterministically into an **in-memory materialized state** using **correct CRDT semantics**. No authorization, no deny-wins yet. Just data correctness and convergence.

---

## Scope (what’s in vs out)

**In**

* A replay engine that consumes M1’s DAG (topo + tie-break) and produces a state.
* **Two minimal CRDTs** implemented correctly:

  1. **MV-Register** (multi-value register) for “set field” semantics.

     * Keeps the **set of concurrent values**; reduces by causality.
     * Provides a **deterministic projection** for UI (e.g., min by `(value_hash)`), but **stores all** concurrent winners.
  2. **OR-Set** (Observed-Remove Set) for add/remove collections.

     * Tagging with unique element IDs (use `op_id` as add-tag); removes reference specific tags.
* **State model**: `ObjMap { obj_id -> Fields }`, where fields can be `MVReg` or `ORSet`.
* **Replay API**: full rebuild + incremental apply (append new ops only).
* **Checkpoints (in-mem only)**: optional snapshot/restore to avoid full rebuild in tests.
* Unit + property tests for **convergence, idempotence, and determinism**.
* CLI: feed a list of ops (any order), print state JSON & the deterministic projection.

**Out**

* Policy/deny-wins/auth epochs.
* Persistence (RocksDB), networking (libp2p), credentials, encryption.
* Non-trivial CRDTs (RGA/text, counters) — keep it small.

---

## Deliverables

### Code

* `crates/core/src/state.rs`

  * `State` struct: object map, per-field CRDT instances.
  * Deterministic JSON export (stable ordering).
* `crates/core/src/crdt.rs`

  * **MVReg**:

    * `put(key, value, ctx)`; internal set keeps versions not dominated by HB.
    * `merge(other)` based on happens-before from DAG (use op ancestry).
    * `project()` returns **deterministic** single value for UI/tests (e.g., lexicographic hash) but also expose `values()` for full set.
  * **ORSet**:

    * `add(elem, tag=op_id)`, `remove(elem, tombstone_tags={...})`.
    * Element present iff it has **add-tags \ tombstones ≠ ∅**.
* `crates/core/src/replay.rs`

  * `replay_full(ops_iter) -> State`
  * `apply_incremental(state, new_ops_iter) -> State`
  * Uses M1 topo order `(parents first; tie: HLC, op_id)`.
* `crates/core/src/op.rs`

  * Extend `Payload` with concrete variants used here:

    * `SetField { obj, field, value }`  → MVReg
    * `SetAdd   { obj, field, elem }`  → ORSet add
    * `SetRem   { obj, field, elem }`  → ORSet remove
  * (Keep Policy variants unused for now.)
* `crates/cli/src/commands.rs`

  * `replay <ops.cbor>` → prints state and deterministic projection.
  * `project <obj field>` → prints chosen value + all MVReg winners.

### Docs

* `docs/architecture.md` (append a short “State & Replay” section).
* `docs/protocol.md` (add payload semantics for MVReg/ORSet and how HB is derived from DAG).

---

## Acceptance criteria (binary)

1. **Deterministic replay**
   Same op set, any insertion order → **identical state** (byte-wise JSON export same).

2. **Convergence**
   For N random DAGs (N≥100), permutations of delivery yield identical state.

3. **MV-Register correctness**

   * If `a → b` (HB), `b` overwrites `a` (single winner).
   * If `a || b` (concurrent), both remain as winners; `project()` picks a stable value but `values()` returns both.

4. **OR-Set correctness**

   * `remove(elem)` only kills **observed add-tags**; concurrent `add(elem)` remains.
   * Add-remove-add with distinct tags behaves per OR-Set spec.

5. **Idempotence**
   Re-applying the same ops (or replay_full twice) does not change state.

6. **Incremental apply parity**
   `replay_full(ops)` equals `apply_incremental(State::empty, ops1); apply_incremental(state, ops2)` for any split of `ops`.

---

## Test plan

**Unit tests**

* `mvreg_hb_overwrite`: later-in-HB write wins, single value.
* `mvreg_concurrent`: two concurrent puts → two winners; projection stable.
* `orset_add_remove_observed`: remove after observing add → absent.
* `orset_concurrent_add_remove`: remove doesn’t see concurrent add → present.
* `orset_readd`: add(tag1), remove(tag1), add(tag2) → present.

**Property tests (proptest)**

* Generate random op DAGs over small keyspace:

  * Mix SetField/SetAdd/SetRem; inject concurrency by varying parents.
  * Check: convergence, idempotence, and CRDT invariants above.

**E2E (CLI)**

* Provide 3 canned histories:

  * Pure HB chain (no concurrency).
  * Two writers concurrent on same field (MVReg winners).
  * OR-Set add/remove races.
    Verify deterministic JSON output across permutations.

---

## Implementation notes

* **HB (happens-before):** Use the M1 DAG ancestry to decide dominance:

  * `op_x HB op_y` iff `op_x` is an ancestor of `op_y` in the DAG.
  * For MVReg: keep versions that are **not dominated** by any other write to that key.
* **Deterministic projection:** Do **not** hide concurrency in state; only for display/tests pick `min( blake3(value_bytes) )`.
* **OR-Set tags:** Use **`op_id`** as the unique add-tag. For removes, compute tombstone set as “all add-tags for (obj, field, elem) that are **HB** visible to the remove op”.
* **Incremental apply:** Track the highest processed topo index; apply only new suffix ops in order.
* **Stable JSON:** Sort objects by UUID, fields by name, sets by element bytes, MVReg winners by value hash so golden tests don’t flap.

---

## Non-goals

* No authorization/deny-wins, no credentials.
* No persistence or networking.
* No performance tuning; correctness first.

---

## Task checklist

* [ ] `state.rs`: object/field model + deterministic export
* [ ] `crdt.rs`: MVReg + ORSet with HB-aware semantics
* [ ] `replay.rs`: full & incremental replay
* [ ] Tests: unit + property + e2e fixtures
* [ ] Docs: extend protocol/architecture with CRDT semantics

---

## Risks / foot-guns

* **Mistaking timestamp order for causality.** Always use DAG ancestry, not HLC, to decide HB.
* **OR-Set remove semantics.** A remove must only kill add-tags it has seen (HB), not all.
* **Projection bias.** Keep MVReg’s full winner set; projection is a view, not the state.

M3 can then introduce **authorization epochs + deny-wins filtering** on top of this replay engine, without touching any of M2’s logic.
