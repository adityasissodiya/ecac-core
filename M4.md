Locked in. M4 is **credential validation**: grants aren’t trusted just because they’re in the log; they must be backed by a **verifiable credential (VC)** that chains to a trusted issuer and isn’t revoked/expired. Still no networking/persistence.

# M4 — Verifiable Credentials Backing Grants (issuer trust, status, expiry)

## Goal

Policy *grants* only count if there’s a **valid VC** binding `(subject_pubkey, role, scope/tags)` with **issuer trust**, **signature validity**, **time validity**, and **revocation status**. Deny-wins replay (from M3) now uses **verified epochs** derived from VCs, not raw Grant events.

---

## Scope

**In**

* VC ingestion + verification pipeline (offline):

  * Parse **W3C VC (JSON-LD)** or **JWT-VC** variant (pick one and freeze).
  * Verify **issuer signature** (DID method or pinned issuer keys).
  * Check **issuance/expiration** times.
  * Check **revocation/status** (StatusList/bitstring provided locally).
  * Extract **claims → (subject_pk, role, tags/scope)**.
* Bind **Grant events** to a VC (by `cred_hash` or embedded VC).
* Build **auth epochs** only from **verified** grants; ignore unverifiable or revoked credentials.
* Minimal **trust store**:

  * Pinned **issuer pubkeys** (or DID documents) in repo.
  * Allowlist of **issuer→schema**.
* Tests ensuring **invalid/expired/revoked** VCs produce **no epochs**.

**Out**

* Online DID resolution, HTTP status fetch, OCSP—**no network**.
* Complex attribute logic beyond role+tags.
* MLS/read-encryption.

---

## Deliverables

### Code

* `crates/core/src/vc.rs`

  * `enum VcFormat { Jwt, JsonLd }` (choose one in M4; recommend **JWT-VC** for simplicity).
  * `struct VerifiedVc { subject_pk, role, scope_tags, nbf, exp, issuer }`
  * `verify_vc(vc_bytes, trust_store, status_cache) -> Result<VerifiedVc>`

    * Signature check (issuer key).
    * Time window: `nbf <= now_hlc_physical <= exp` (**use HLC.physical** only for comparing VC validity windows; document this).
    * Status check: `status_cache.is_revoked(cred_id) == false`.
* `crates/core/src/trust.rs`

  * `TrustStore { issuers: HashMap<IssuerId, IssuerKey> , schemas: … }`
  * Load from `trust/issuers.toml` committed in repo.
* `crates/core/src/status.rs`

  * `StatusCache` for revocation lists (local files, e.g., compressed bitstrings).
  * `is_revoked(cred_id) -> bool`
* `crates/core/src/op.rs`

  * `Payload::Grant { cred_hash, … }` (no raw role/tags in M4; they come from VC).
  * `Payload::Credential { cred_id, cred_bytes, format }` to carry VCs on the log.
  * (Optional) `Payload::StatusList { list_id, chunk }` to distribute revocations via the log.
* `crates/core/src/policy.rs`

  * Change `build_auth_epochs`:

    * For each `Grant{cred_hash}`, look up `VerifiedVc` by hash in a **verified VC index**.
    * Epochs derive from `vc.nbf..vc.exp` intersected with any `Revoke` events (still supported).
* `crates/cli/`

  * `vc-verify <vc.jwt>` → prints extracted claims.
  * `vc-attach <op_id> <vc.jwt>` → emits `Credential` + `Grant{cred_hash}` ops for testing.
  * `replay` unchanged interface; now reflects VC-backed policy.

### Docs

* `docs/policy-model.md` → “Grants backed by VCs” section (issuer trust, status, time).
* `docs/protocol.md` → op formats for `Credential`, `Grant{cred_hash}`, optional `StatusList`.
* `docs/architecture.md` → updated replay pipeline diagram (ops → VC verify → epochs → filter → state).

---

## Acceptance criteria (binary)

1. **Only-VC-backed grants count**
   Grants without a verifiable VC (missing or invalid `cred_hash`) **never** create epochs.

2. **Issuer signature required**
   VCs signed by keys not in `TrustStore` are **rejected**.

3. **Time validity enforced**
   Ops with `op.hlc` outside `vc.[nbf,exp)` are **skipped** even if a Grant exists.

4. **Revocation honored**
   If `StatusCache` marks the credential as revoked, **no epoch** is produced (or an existing epoch is truncated starting from `revoked_at` if encoded).

5. **Determinism**
   Given identical ops + identical trust/status files, all nodes produce identical filtered state.

6. **Interop tests**
   Sample JWT-VCs with: valid, expired, not-yet-valid, wrong issuer, and revoked cases → expected pass/fail table.

---

## Test plan

**Unit tests**

* `vc_valid_allows`: valid VC + Grant → ops within `[nbf,exp)` apply.
* `vc_expired_denies`: expired VC → zero epochs → ops skipped.
* `vc_wrong_issuer`: signature under unknown key → skipped.
* `vc_status_revoked`: status bit set → skipped regardless of times.
* `vc_hash_mismatch`: Grant references wrong hash → skipped.

**Property tests**

* Random mixes of valid/invalid VCs + random op DAGs:

  * Assert: no op is applied unless an epoch exists from a valid VC.

**E2E (CLI)**

* Scenario: user edits while VC is valid; later a `StatusList` chunk marks VC revoked; replay removes subsequent ops.

---

## Implementation notes

* **Pick a VC format now**: **JWT-VC** with a fixed claim set is simplest (no JSON-LD canon issues). Claims:

  ```json
  {
    "sub_pk": "<base58/hex pubkey>",
    "role": "hv_test_engineer",
    "scope": ["hv-test","electrical"],
    "nbf":  ...,
    "exp":  ...,
    "iss":  "oem-issuer-1",
    "jti":  "uuid-cred-id",
    "status": {"id":"list-2025-10","index":12345}
  }
  ```
* **Clock source**: compare `nbf/exp` to the **physical part of HLC** embedded in ops/log. Do **not** call wall clock during replay; depend only on event/VC data.
* **Status lists**: store local files under `trust/status/…`. In M4, treat them as static input; in later milestones you can update via ops.
* **Security**: do **constant-time** signature verify (ed25519 already is). Treat VC bytes as immutable; hash = BLAKE3 on canonical byte representation (for JWT, hash the compact form).

---

## Non-goals

* Dynamic online issuer discovery (DID resolution), networked revocation fetch.
* Complex ABAC (location/time-of-day), credential binding to devices.
* Key rotation protocols (pin issuer keys per version for now).

---

## Task checklist

* [ ] Implement `TrustStore` loader (issuers.toml)
* [ ] Implement `StatusCache` (bitstring + test data)
* [ ] Implement `verify_vc` (JWT-VC path)
* [ ] Extend ops (`Credential`, `Grant{cred_hash}`)
* [ ] Wire verified VCs into `build_auth_epochs`
* [ ] Tests: unit, property, CLI fixtures
* [ ] Docs: protocol + policy-model updates

---

## Risks / foot-guns

* **JSON-LD canon hell**: avoid by choosing JWT-VC in M4.
* **Wall-clock usage**: don’t; rely on HLC/time fields already in data.
* **Ambiguous scope mapping**: ensure VC `scope` semantics match M3’s `resource_tags` rule (e.g., “intersects”). Freeze it and test it.

M5 can introduce **persistence (RocksDB) + checkpoints**, or **gossip sync**, whichever you want to nail next.
