Locked. M8 = **audit trail & forensics**. We’ll make “who did what, when, and why” provable, end-to-end, without changing core semantics.

# M8 — Tamper-Evident Audit Trail (produce, verify, explain)

## Goal

Every important action (ingest, apply, skip, view/export) is **recorded, signed, and hash-linked** so you can later prove:

* who authored each op,
* when/why it was **applied** or **skipped** (deny-wins),
* who **viewed** which objects/fields and when (optional but valuable),
* that the audit log itself hasn’t been altered.

Auditing must be **deterministic**, **append-only**, and **verifiable offline**.

---

## Scope

**In**

* An **audit event stream** (separate from data/policy ops) with:

  * `IngestedOp`, `AppliedOp`, `SkippedOp{reason}`, `ViewEvent`, `CheckpointEvent`, `SyncEvent`.
* Each audit event is:

  * canonical-encoded (CBOR),
  * **hash-linked** (prev hash),
  * **signed** by the node key (not the user key).
* On-disk **audit log** with rotation.
* A **verifier** that checks the chain (hashes, signatures), cross-checks against op store, and recomputes expected `Applied/Skipped` from replay to spot inconsistencies.
* Deterministic **export** (`audit.jsonl`).

**Out**

* Centralized SIEM integrations, fancy privacy tooling, long-term retention policies (document basics only).

---

## Audit model (frozen)

### Event types (payloads)

```
enum AuditEvent {
  IngestedOp { op_id, author_pk, parents[], verified_sig: bool },
  AppliedOp  { op_id, topo_idx, reason: "authorized" },
  SkippedOp  { op_id, topo_idx, reason: "deny_wins" | "invalid_sig" | "bad_parent" | "revoked_cred" | "expired_cred" | "out_of_scope" },
  ViewEvent  { viewer_node, obj, field, projection_hash },   // optional M8+, feature-gated
  Checkpoint { checkpoint_id, topo_idx, state_digest },
  SyncEvent  { peer_id, fetched: u32, duplicates: u32 }
}
```

### Chain format

* `audit_entry = { seq, ts_monotonic, prev_hash, event, node_id, signature }`
* `entry_hash = BLAKE3("ECAC_AUDIT_V1" || canonical(audit_entry_without_sig))`
* `signature = ed25519(node_sk, entry_hash)`

**Guarantees:**

* Altering or removing any entry breaks the chain.
* Replay determinism means we can **re-derive** Applied/Skipped from ops and compare to the audit log.

---

## Deliverables

### Code

* `crates/store/src/audit.rs`

  * `AuditWriter`:

    * `append(event: AuditEvent) -> seq`
    * internal: tracks `prev_hash`, writes canonical bytes to `audit/segment-XXXX.log` (append-only), fsync on commit.
  * `AuditReader`:

    * iterate entries; verify hash chain and signatures.
  * Rotation: new segment after size/time limit; maintain `index.json` of segments with first/last seq, first/last hash.

* `crates/core/src/replay.rs`

  * Emit `AppliedOp` / `SkippedOp{reason}` **after** each decision (guarded by a feature flag `audit` to keep hot path lean if needed).
  * On `verify_sig` failure or missing parent rejection in ingest path, emit `SkippedOp` with reason.
  * On checkpoint create → `Checkpoint`.

* `crates/net/src/sync.rs`

  * After successful fetch batch: `SyncEvent { fetched, duplicates }`.

* `crates/cli/`

  * `audit-verify <db_path>`:

    * verifies chain integrity (hashes/signatures),
    * cross-checks: recompute replay; diff `Applied/Skipped` vs audit (seqs, reasons).
  * `audit-export <db_path> --jsonl`:

    * deterministic JSONL export for paper artifacts.
  * `audit-cat <segment>`: raw decode for debugging.

### Docs

* `docs/audit.md`

  * Threat model: tamper evidence, not secrecy.
  * Event types, chain format, signature scheme.
  * Cross-check algorithm (replay vs audit).
* Update `docs/evaluation-plan.md`

  * Add “audit integrity” section + how to reproduce `audit-verify` runs.

---

## Acceptance criteria (binary)

1. **Chain integrity**

   * `audit-verify` passes on clean logs: all hashes/signatures valid, no gaps in `seq`, `prev_hash` matches.

2. **Replay cross-check**

   * For a given DB, recomputing replay decisions yields **identical** `Applied/Skipped` counts and exact `(op_id, topo_idx, reason)` tuples as in the audit log.

3. **Tamper detection**

   * Flip one byte in a segment → `audit-verify` fails with precise location (seq no., expected vs got hash).
   * Delete a segment → failure with “gap at seq S”.

4. **Deterministic export**

   * Two exports of the same DB produce byte-identical `audit.jsonl`.

5. **Crash-safety**

   * Kill mid-append; on restart, `audit-verify` either:

     * accepts up to the last **fsynced** entry, or
     * truncates the last partial entry and reports “truncated tail repaired” (documented behavior).
   * No silent acceptance of half-written entries.

6. **Reason coverage**

   * For each negative path (bad sig, revoked cred, out of scope), there’s a corresponding `SkippedOp` with the right reason.

---

## Test plan

**Unit tests**

* `chain_basic`: append N events; verify chain & signatures.
* `corrupt_byte`: mutate payload → verify fails at that seq.
* `missing_prev`: splice out an entry → verify detects gap.

**Replay cross-check tests**

* Build small histories where:

  * allowed ops only → all `Applied`.
  * revoke before op → `Skipped(deny_wins)`.
  * bad signature → `Skipped(invalid_sig)`.
  * expired VC → `Skipped(expired_cred)`.
  * scope mismatch → `Skipped(out_of_scope)`.
* `audit-verify` ensures perfect match with recomputed replay.

**Crash tests**

* Inject crash between `write()` and `fsync()`; ensure truncated entry is handled (truncate to last good offset) and reported.

**Property tests**

* Random histories (ops + policy + VCs); run replay; assert:

  * `applied + skipped == total_ingested`,
  * audit export → parse → verify equals recomputed replay.

**Integration (with net)**

* Two nodes exchange ops; both produce `SyncEvent`; after heal, export both audits and diff:

  * same `Applied/Skipped` decisions,
  * different local `IngestedOp` orders allowed, but chain valid on each.

---

## Implementation notes

* **Separation of identities**: audit events are signed with **node** keys; **ops** remain signed with **user** keys. Verifier must check both (different trust domains).

* **Canonical encoding**: reuse the same CBOR canonicalization as ops; define `AUDIT_V1` domain separator for hashes. Never re-serialize entries during verify; compute hash from stored bytes after zeroing the sig field or by signing a known “preimage” structure.

* **Timestamps**: `ts_monotonic` uses a monotonic counter or HLC logical component; avoid wall-clock to keep replay independent of system time. (You can include wall time as optional, non-authoritative field for human readability.)

* **Privacy**: `ViewEvent` can leak what a user looked at; gate behind `--audit-views` and document retention. Redact payloads as hashes if needed (store `projection_hash`, not full value).

* **Rotation**: simple size-based (e.g., 8–32 MB); each segment starts with a header `{segment_id, first_seq, first_prev_hash}`. Index file lists segments with their first/last hashes for quicker verification.

* **State digest**: `Checkpoint.state_digest = blake3(deterministic_state_export)` so you can assert that the snapshot matches replay.

* **Performance**: append audit entries in a separate file from RocksDB; use buffered writes + fsync on batch boundaries (e.g., after each replay batch). Audit overhead is acceptable; we prioritize integrity.

---

## Non-goals

* Encryption of audit logs (can be layered later).
* Multi-party notarization (e.g., external transparency log); optional future anchoring.
* GDPR redaction workflows; we’ll just document PII considerations.

---

## Task checklist

* [ ] Define `AuditEvent` + canonical encoding
* [ ] Implement `AuditWriter/Reader` with hash-link + signatures
* [ ] Emit audit events from ingest, replay, checkpoints, sync
* [ ] CLI: `audit-verify`, `audit-export`, `audit-cat`
* [ ] Tests: unit, cross-check, crash, property, integration
* [ ] Docs: `docs/audit.md` + eval plan update

---

## Risks / foot-guns

* **Re-encoding mismatch**: sign a **stable preimage**; don’t sign whatever serde happens to spit this week.
* **Audit vs replay divergence**: ensure audit emission is **in the same code path** as the decision; no parallel “shadow” code.
* **Partial writes**: must detect and safely truncate; never accept a partial entry.
* **PII leakage**: be careful with `ViewEvent`; default off, hash values.

Ship M8 and you’ll have verifiable evidence for every claim about deny-wins decisions and system behavior—something most papers hand-wave.
