Locked. For M9 we’ll add **minimal read-control** so we’re not hand-waving confidentiality. Keep it small, deterministic, and compatible with everything you’ve built.

# M9 — Minimal Read-Control via Per-Tag Encryption & Key Grants

## Goal

Confidential fields are stored/transmitted **encrypted** unless the reader holds a valid **KeyGrant** (VC-backed) for the field’s tag(s). Revocation triggers **key rotation** so future writes are unreadable to revoked parties. No re-encryption of history in M9 (forward secrecy from rotation point onward).

---

## Scope

**In**

* **Per-tag symmetric keys**: `TagKey{tag, version, alg, key_bytes}`.
* **KeyGrant events** (in the same op log), backed by **verified VCs** (from M4):

  * `KeyGrant{subject_pk, tag, key_version}` with `cred_hash`.
* **Encrypt-on-write** for fields tagged `confidential` (you decide tag set).

  * Cipher: **XChaCha20-Poly1305** (AEAD).
  * Envelope format: `Enc{tag, key_version, nonce, aead_tag, ciphertext}` with AAD = `(op_id, obj, field)`.
* **Key rotation on revocation**:

  * Emit `KeyRotate{tag, new_version, new_key}` signed by an authorized *KeyAdmin* (its own VC).
  * Writes after rotation use `new_version`.
* **Outbound filtering**:

  * Net path ships encrypted blobs for confidential fields; **never** plaintext to peers lacking a matching KeyGrant.
* **Local keyring**:

  * `Keyring{ (tag, version) -> key }`, persisted in store.

**Out**

* MLS/OpenMLS group key mgmt (too heavy for M9).
* Historical re-encryption (we’ll document limits).
* Attribute-rich ABAC for read—stick to tag+role only.

---

## Data & op formats (frozen)

### New payloads

```
KeyGrant   { subject_pk, tag, key_version, cred_hash }
KeyRotate  { tag, new_version, new_key_enc? }   // simplest: key in plaintext inside log signed by KeyAdmin (ok for prototype); optionally wrap per-subject out-of-band later
```

> For prototype correctness, we place `new_key` **in the log**, signed by KeyAdmin, so every node learns it. Access is gated by shipping **ciphertexts**, not by hiding keys—peers without KeyGrant can’t decrypt because they never receive those keys in their local **keyring import** (policy filter).

### Encrypted value

```
EncV1 {
  tag: Tag,
  key_version: u32,
  nonce: [24],
  aead_tag: [16],
  ct: bytes,
  aad = blake3("ECAC_AAD" || op_id || obj || field)
}
```

---

## Deliverables

### Code

* `crates/core/src/crypto.rs`

  * `encrypt_value(tag, key_version, key, plaintext, aad) -> EncV1`
  * `decrypt_value(keyring, enc, aad) -> Option<plaintext>`

* `crates/core/src/policy.rs`

  * Extend epoch index with **read** epoch:

    * If subject has VC for `(role -> read:tag)`, AND a `KeyGrant{tag, key_version}` valid at `op.hlc`, then read allowed.
  * Map roles → `{read_tags, write_perms}` (write already exists from M3).

* `crates/core/src/op.rs`

  * Mark which fields are **confidential** (static `(obj,field)->TagSet` resolver).
  * On **data op creation**: if field has `confidential` tag, caller passes plaintext → core **encrypts** using current `(tag,key_version)` from local keyring; stores **EncV1** in op payload.

* `crates/store/src/keys.rs`

  * `Keyring` persisted CF: `(tag||version) -> key`.
  * Import path:

    * When replaying `KeyRotate{tag,new_version,new_key}`, **store** `(tag,new_version)`.
    * When processing `KeyGrant{subject,tag,version}`, update read-epoch index (no key material change here—key presence is global; authorization is per-subject).

* `crates/core/src/replay.rs`

  * On materialization for a viewer (CLI/UI):

    * If field is `EncV1`, attempt `decrypt_value` with key from keyring.
    * If decrypt fails or policy says no read epoch, show `"<redacted>"` or omit.

* `crates/net/src/serializer.rs`

  * Ensure encrypted payloads stay opaque; no accidental plaintext leak.

* `crates/cli/`

  * `keyrotate <tag>` → emits `KeyRotate` with new random key/version.
  * `grant-key <subject_pk> <tag> <version> <vc.jwt>` → emits `KeyGrant{cred_hash}` + `Credential`.
  * `show <obj field>` prints plaintext if permitted else `<redacted>`.

### Docs

* `docs/policy-model.md` → add read model (tags, KeyGrant, rotation semantics).
* `docs/protocol.md` → EncV1 format, KeyGrant/KeyRotate ops.
* `docs/threat-model.md` → clarify confidentiality bounds (no historical rekey).

---

## Acceptance criteria (binary)

1. **Confidentiality at rest/in transit**

   * Confidential fields are **never stored or sent** in plaintext; store contains only `EncV1` blobs.

2. **Access gating works**

   * User without read epoch for `(tag,version)` sees `<redacted>`; with epoch sees plaintext.

3. **Rotation enforces forward secrecy**

   * After `KeyRotate(tag → v+1)`, new writes use `v+1`; a subject who only has KeyGrant for `v` **cannot read** post-rotation writes.

4. **Policy determinism**

   * Given the same ops and keyring, all replicas render identical redaction/plaintext decisions.

5. **No impact on write-safety**

   * Deny-wins (M3) behavior unchanged; encryption layer is orthogonal.

---

## Test plan

**Unit**

* `enc_dec_roundtrip`: XChaCha20-Poly1305 success; AAD tamper fails.
* `redaction_without_grant`: decrypt attempt fails → redacted.
* `grant_allows_read`: with KeyGrant + role read perm → plaintext visible.
* `rotation_blocks_future`: rotate; create new op; old-grant subject can’t read.
* `old_history_still_readable`: pre-rotation ciphertext remains readable to those with the old grant (documented behavior).

**Integration**

* Build scenario:

  * Create confidential field; grant read to A; B has no grant.
  * A sees plaintext; B sees redacted.
  * Rotate key; write new value; A (with updated KeyGrant) sees new plaintext; B still redacted.
* With net (M6): ensure only encrypted blobs traverse; convergence and redaction decisions match across nodes.

**Property**

* Random ops with random rotations/grants; assert:

  * No plaintext bytes for confidential fields appear on disk.
  * Redaction predicate is deterministic across permutations.

---

## Implementation notes

* **Key distribution simplification (prototype)**
  We place `new_key` in `KeyRotate` ops (global knowledge), but **rendering** plaintext still requires a **KeyGrant** epoch for the viewer. This keeps implementation small while preventing accidental plaintext exposure. If you want stricter separation, encrypt `new_key` payload toward authorized subjects later (M9+).

* **Key versioning**
  Maintain `(tag) -> current_version` in `meta`; writer must refuse to encrypt under stale version.

* **AAD discipline**
  Bind AEAD to `(op_id, obj, field)` so ciphertext can’t be transplanted between fields.

* **CLI viewer identity**
  Rendering requires a “current subject” (public key) to evaluate read epochs; pass `--subject-pk` to `show`.

* **Deterministic renders**
  JSON export should emit either the decrypted value or a constant `"<redacted>"` token—never depend on environment.

---

## Non-goals

* No re-encryption of historical data on revoke (documented: **forward secrecy only** from rotation point).
* No per-subject encrypted key envelopes (kept global for prototype simplicity).
* No MLS or group membership proofs.

---

## Task checklist

* [ ] Define `EncV1`, `KeyRotate`, `KeyGrant` payloads
* [ ] Implement XChaCha20-Poly1305 encrypt/decrypt with AAD
* [ ] Persist `Keyring`; import on `KeyRotate`
* [ ] Extend policy for read epochs + CLI subject identity
* [ ] Wire encrypt-on-write & decrypt-on-read paths
* [ ] Implement CLI `keyrotate`, `grant-key`, `show`
* [ ] Tests: unit, integration, property
* [ ] Docs: protocol, policy, threat model updates

---

## Risks / foot-guns

* **Leaking plaintext via logs/serde**: ensure debug/trace never prints plaintext; fuzz `serde` paths.
* **Using wrong key_version**: enforce writer checks; add test that stale version is rejected.
* **AAD misuse**: forgetting AAD breaks bound integrity; test transplant attacks.
* **Reviewer pushback on global key visibility**: counter by stating **read access is enforced by grants + ciphertext**, keys are not auto-imported; move to per-subject envelopes if needed (M9+).

Ship M9 and you can honestly say the prototype **enforces write policies** and **protects confidential reads** with forward secrecy after revocation—enough to survive reviewer scrutiny without bloating the system.
